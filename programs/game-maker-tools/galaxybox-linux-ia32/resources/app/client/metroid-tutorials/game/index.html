<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Metroid Example</title>


    <link rel="stylesheet" href="qunit-2.2.1.css"/>


    <script src="../assets/js/dat.gui.js"></script>


    <script src="../../assets/js/Tween.js"></script>

    <script src="../../dist/obj/Animation.js"></script>

    <script src="../../dist/obj/Force.js"></script>
    <script src="../../dist/obj/GameMedia.js"></script>


    <script src="../../dist/Quazar.js"></script>


    <script src="../../dist/obj/Sprite.js"></script>


    <script src="../../dist/obj/GamepadAdapter.js"></script>


    <script src="../../dist/script/Terrain.js"></script>


    <script src="../assets/js/dat.gui.interface.js"></script>

    <script src="../assets/js/Jquery.js"></script>


    <style>
        body {
            color: #888888;
            font-family: Monospace;
            font-size: 13px;
            background-color: #000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 400px;
            left: calc(50% - 200px);
            text-align: center;
        }

        a {
            color: #00f;
        }
    </style>


</head>
<body>

<div id="container"></div>
<div id="info"></div>

<canvas id="myCanvas"></div>


    <script>

        /****************************
         *
         * Boom gameEngine::
         *
         * Designed to do 3 things:
         *
         * 1. Define animations and movements with controller events and over specific timing
         *
         * 2. Instantiate and Disperse those animations over 2D / 3D spaces during runtime
         *
         * 3. Instantiate and Disperse animations from a GUI
         *
         *
         * Example Calls for Sprite:
         *
         * var sprite = new Sprite();
         *
         * sprite.jump({height:100, duration:100})
         * .animate(new Animation({}))
         * .on('button_0')
         * .lockout({till:SPRITE.STATE.IS_GROUNDED});
         *
         * sprite.damage()
         * .animate()
         * .on()
         * .collision({with:myListArray});
         *
         * * sprite.shoot()
         * .animate(new Animation)
         * .on('button_1')
         * .lockout({duration:20});
         *
         *
         * Sprite Chain Calls:
         *
         * sprite
         * .move || accel || shoot || jump || gravity
         *
         * Example Calls for Dispersion Unit
         *
         * var dUnit = new DispersionUnit();
         *
         * dUnit.disperse({object, shape, total}).randomize(probability)
         * .within(spacerange) || over(timerangeperbirth)
         * .perpetual()
         * .onUpdate(function(sprite) { //your update here. make a blooming fire flower, etc... the sprite
     * can do anything instructed once it is born })
         *
         * *************************/







        var Game = Game || {};

        var GameApp = GameApp || {

                GameWindow: {},

                canvas: {},

                ctx: {},

                collective_physics: {},

                physical_sprites: Game.sprites,

                non_physical_sprites: [],

                player: {},

                is_init: false,

                terrain: [],

                master_tile: {},

                WIDTH: 0,

                HEIGHT: 0,

                gravity: function () {

                    Quazar.each(GameApp.physical_sprites.concat([GameApp.player]), function (ix, item) {

                        if (!item.speed) {
                            item.speed = new Vector3(0, 1, 0);

                        }

                        if (item.speed.y < 5) {

                            item.speed.y += 0.05;

                        }


                        var focusTile = GameApp.master_tile;


                        if (item.position.y + item.size.y < focusTile.position.y) {
                            item.position.y += item.speed.y;

                        }
                        else {
                            //handle state params::

                            item.onGround = true;

                            if (item.speed) {
                                item.speed.y = 0
                            }
                            ;

                            if (item.state && item.state.button_timers[0] > 10) {
                                item.state.airborne = false;

                                if (item.jump_anime) {

                                    item.jump_anime.reset();

                                }

                            }


                        }


                    });


                },


                size: function (x, y) {

                    this.canvas.width = x;

                    this.canvas.height = y;

                },

                update: function () {

                    this.gravity();

                    if (!this.is_init) {
                        return 0;

                    }

                    console.log('Game Update');

                    this.GameWindow.render();

                },


                render: function () {

                    if (!this.is_init) {
                        return 0;

                    }

                    this.size(1000, 1000);

                    this.GameWindow.draw();

                },

                init: function () {

                    this.WIDTH = window.innerWidth;

                    this.HEIGHT = window.innerHeight;

                    Game.WIDTH = this.WIDTH;
                    Game.HEIGHT = this.HEIGHT;

                    document.getElementById('container').innerHTML += "<canvas></canvas>";

                    // 1. demonstrate that the threejs canvas can be intercepted at runtime

                    this.canvas = document.getElementsByTagName('CANVAS')[0];

                    this.ctx = this.canvas.getContext('2d');


                    this.forces = [];


                    // the player sprite : this sprite will switch between several animations to show character-movement

                    this.player = new Sprite('Samus-Like Character', 'a video game sprite', {
                        pos: new Vector2(200, 120),
                        size: new Vector2(50, 52)
                    });


                    this.player.stats = {

                        speed: 3

                    };


                    terrain_init(this.non_physical_sprites);


                    this.player.state = {

                        button_timers: {

                            0: 100,

                            1: 100,

                            2: 100,

                            3: 100,

                            4: 100

                        }

                    };


                    this.master_tile = {position: new Vector3(0, 300, 0)}; //player never falls below this level

                    this.terrain.push(this.master_tile);


                    //jump_anime :: the default jump animation for our character

                    this.player.jump_anime = new Animation({
                        src: "image/samus2.png",
                        delay: 7,
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 0, 0), new Vector3(4, 0, 0))
                    });

                    //run_anime :: the default run animation for our character

                    this.player.run_anime = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        earlyTerm: 9,
                        frameOffset: new Vector3(0, 10, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 17, 0), new Vector3(3, 19, 0))
                    });

                    //run_anime :: the default run animation for our character

                    this.player.current_run_anime = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        earlyTerm: 9,
                        frameOffset: new Vector3(0, 10, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 17, 0), new Vector3(3, 19, 0))
                    });


                    //player.run_aim_diag_up :: player aims to shoot while running


                    this.player.run_aim_diag_up = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        earlyTerm: 9,
                        frameOffset: new Vector3(0, 10, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 20, 0), new Vector3(3, 22, 0))
                    });

                    //player.run_aim_straight :: player aims to shoot while running

                    this.player.run_aim_straight = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        earlyTerm: 9,
                        frameOffset: new Vector3(0, 10, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 23, 0), new Vector3(3, 25, 0))
                    });


                    //player.run_aim_diag_down :: player aims to shoot while running

                    this.player.run_aim_diag_down = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        earlyTerm: 9,
                        frameOffset: new Vector3(0, 10, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 26, 0), new Vector3(3, 28, 0))
                    });


                    this.player.jump_aim_diag_up = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        hang: true,
                        frameOffset: new Vector3(0, 5, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 8, 0), new Vector3(1, 8, 0))
                    });


                    this.player.jump_aim_diag_down = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        hang: true,
                        frameOffset: new Vector3(0, 8, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 9, 0), new Vector3(1, 9, 0))
                    });


                    this.player.jump_aim_straight = new Animation({
                        src: "image/samus2.png",
                        delay: 3,
                        hang: true,
                        frameOffset: new Vector3(0, 15, 0),
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 12, 0), new Vector3(1, 12, 0))
                    });


                    //player.idle_anime :: the idle frame, in which the character stands inactive

                    this.player.idle_anime = new Animation({
                        src: "image/samus2.png",
                        delay: 4,
                        frameSize: new Vector3(50, 50, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 0, 0), new Vector3(0, 0, 0))
                    });


                    //this.player.enter_morph_ball :: player enters into ball-position

                    this.player.enter_morph_ball = new Animation({
                        src: "image/samus2.png",
                        delay: 8,
                        earlyTerm: 8,
                        frameSize: new Vector3(50, 50, 0),
                        frameOffset: new Vector3(0, 12, 0),
                        frameBounds: new VectorBounds(new Vector3(2, 28, 0), new Vector3(3, 30, 0))
                    });


                    //this.player.flip_while_airborne  :: player flips while airborne

                    this.player.flip_while_airborne = new Animation({
                        src: "image/samus2.png",
                        delay: 40,
                        frameSize: new Vector3(50, 50, 0),
                        frameOffset: new Vector3(0, 12, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 31, 0), new Vector3(3, 32, 0))
                    });

                    //this.player.super_flip_while_airborne  :: player super-flips while airborne :: use this for special moves

                    this.player.super_flip_while_airborne = new Animation({
                        src: "image/samus2.png",
                        delay: 40,
                        frameSize: new Vector3(50, 50, 0),
                        frameOffset: new Vector3(0, 12, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 33, 0), new Vector3(3, 33, 0))
                    });

                    //player.energy_rope_swing_right && this.player.energy_rope_swing_left  :: 2 animations to be combined into one for the full energy swing


                    this.player.energy_rope_swing_right = new Animation({
                        src: "image/samus_swing_die.png",
                        delay: 40,
                        frameSize: new Vector3(70, 55, 0),
                        frameOffset: new Vector3(0, 0, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 0, 0), new Vector3(2, 1, 0))
                    });

                    this.player.energy_rope_swing_left = new Animation({
                        src: "image/samus_swing_die.png",
                        delay: 40,
                        frameSize: new Vector3(70, 55, 0),
                        frameOffset: new Vector3(0, 23, 0),
                        frameBounds: new VectorBounds(new Vector3(0, 3, 0), new Vector3(1, 4, 0))
                    });


                    //Combine the above two into one full animation

                    this.player.energy_full_rope_swing = this.player.energy_rope_swing_right;

                    this.player.energy_full_rope_swing.delay = 5;

                    this.player.energy_full_rope_swing.frames = this.player.energy_full_rope_swing.frames.concat(this.player.energy_rope_swing_left.frames);

                    for (var x = this.player.energy_full_rope_swing.frames.length - 1; x >= 1; x--) {
                        this.player.energy_full_rope_swing.frames.push(this.player.energy_full_rope_swing.frames[x]);

                    }
                    ;

                    this.player.setAnimation(this.player.idle_anime);

                    // this.player.movement('jump', new Movement('../assets/sound/effect/ribbit.mp3'));

                    var sound = new GameSound('../assets/sound/effect/ribbit.mp3');

                    this.player.add(sound);

                    this.player.stats = {jump_height: 100};

                    this.player.stat = function (key) //note both animations and sprites can get stats
                    {
                        if (!this.stats.hasOwnProperty(key)) {
                            return console.error('The stat does not exist');

                        }

                        return this.stats[key];

                    };

                    this.player.timer = 0;


                    this.player.shoot = function (options) {

                        var angleSpread = options.angleSpread || 0;


                        console.error('TODO: create the shoot algorythm');


                    };


                    this.player.jump({height: 100, duration: 100, switch: "onGround"})
                        .animate(this.player.jump_anime)
                        .on({controller: 0, ctrl: 0});

                    this.player.accel({key: "x", accel: 0.25, speed: 5.0, extras: {flipX: false}, switch: "onGround"})
                        .animate(this.player.current_run_anime)
                        .on({
                            controller: 0,
                            ctrl: 'stickleft',
                            ctrl_factor: 'x',
                            max_ctrl: {x: 1.0},
                            min_ctrl: {x: 0.4}
                        });

                    this.player.accel({key: "x", accel: 0.25, speed: -5.0, extras: {flipX: true}, switch: "onGround"})
                        .animate(this.player.current_run_anime)
                        .on({
                            controller: 0,
                            ctrl: 'stickleft',
                            ctrl_factor: 'x',
                            max_ctrl: {x: -0.4},
                            min_ctrl: {x: -1.0}
                        });


                    this.player.idleX = function () {
                        this.deccelX(0.1);

                        this.setAnimation(this.idle_anime);

                        //temp anime test

                    };


                    this.player.update = function () {
                        this.animation_busy = false;

                        this.assertSpeed();

                        for (var x in this.speed) {
                            this.position[x] += this.speed[x];

                        }

                        this.selected_animation.animate();

                        for (var x in this.state.button_timers) {
                            this.state.button_timers[x] += 1;

                        }
                        ;

                        if (Math.abs(this.speed.x) < 0.5 && this.onGround) {
                            this.idleX();


                        }

                    };

                    this.player.active = true;

                    this.physical_sprites.push(this.player);


                    this.canvas.width = 1000;

                    this.canvas.height = 1000;

                    this.is_init = true;


                    var controller = Game.gamepads[0];


                    var player = this.player; //a reference to our player

                    __gameInstance.player = this.player;


                    __gameInstance.buttons = {};


                    var stickLeftPlayerCalls = function (x, y) {

                        if (player.aim) {

                            if (y < -0.2) {


                                player.setAnimation(player.onGround ? player.run_aim_diag_up : player.jump_aim_diag_up);


                            }
                            else if (y > 0.2) {

                                player.setAnimation(player.onGround ? player.run_aim_diag_down : player.jump_aim_diag_down);


                            }
                            else {

                                player.setAnimation(player.onGround ? player.run_aim_straight : player.jump_aim_straight);


                            }

                        }

                    }


                    //DEFAULT CALLBACK FOR LEFT STICK

                    controller.on('stick_left', function (x, y) {

                        if (__gameInstance.event_args_list.length >= 1) {

                            for (var xix = 0; xix < __gameInstance.event_args_list.length; xix++) {

                                var evt = __gameInstance.event_args_list[xix];

                                if (evt.ctrl) {

                                    var key = evt.ctrl.replace('_', '').replace(' ', '');


                                    var myArgs = JSON.parse(JSON.stringify(evt.args));


                                    if (evt.args.ctrl_factor == 'y')
                                        myArgs.speed = Math.abs(y) * Math.abs(evt.args.speed);


                                    if (key == 'stickleft' || key == 'leftstick') {


                                        if ((x < 0 && evt.args.speed < 0) || (x > 0 && evt.args.speed > 0)) {
                                            if (evt.args.min_ctrl && x < evt.args.min_ctrl.x) {
                                                x = 0;

                                            }

                                            else if (evt.args.max_ctrl && x > evt.args.max_ctrl.x) {
                                                x = 0;

                                            }
                                            else {
                                                if (evt.animation) {
                                                    evt.object.setAnimation(evt.animation);

                                                }

                                            }

                                            if (evt.args.ctrl_factor == 'x')
                                                myArgs.speed = Math.abs(x) * evt.args.speed;

                                            evt.object[evt.key](myArgs);
                                        }


                                    }

                                }


                            }


                        }


                        stickLeftPlayerCalls(x, y);

                    });


                    //DEFAULT BUTTONS CALLS

                    for (var x = 0; x < 50; x++) {

                        controller.on('button_' + x, function (pressed) {

                            if (pressed && __gameInstance.event_args_list.length >= 1) {

                                for (var x = 0; x < __gameInstance.event_args_list.length; x++) {

                                    var evt = __gameInstance.event_args_list[x];

                                    if (evt.ctrl == 0 || evt.ctrl == '0') {

                                        evt.object[evt.key](evt.args);

                                        if (evt.animation) {

                                            evt.object.setAnimation(evt.animation);

                                        }


                                    }

                                }

                            }

                        });

                    }


                    controller.on('button_' + 2, function (pressed) {

                        player.aim = pressed;


                    });



                    this.GameWindow = new GameWindow({
                        canvas: this.canvas,
                        ctx: this.ctx,
                        sprites: this.physical_sprites.concat(this.non_physical_sprites),
                        forces: this.forces
                    }, function () {

                        //  console.log('Game Update passed');

                    });

                }


                ,

                construct_game: function () {

                    alert('Constructing game');


                    var fillLevel = function (positions, blockSize) {

                        var assembler = {

                            specials: {

                                trajectoryReachClear: function () {
                                    //for platforming :: check that each playable part of a level

                                    //is within the trajectory-reach of other parts

                                    //player can always jump or spring or ride a platform to where they're going

                                    //nothing is out of reach

                                }

                            },

                            ground_tile_small: function (chanceFloat) {

                                //return the next tile on a growing stack of tiles

                                //return the next tile on a growing stack of tiles

                                if(Math.random() * 1.0 < chanceFloat)
                                {

                                    return new Sprite();


                                }
                                else
                                {
                                    return false;

                                }



                            },

                            ground_tile_large: function (chanceFloat) {

                                //return the next tile on a growing stack of tiles

                                //return the next tile on a growing stack of tiles

                                var tile = new Sprite();

                                if(chanceFloat == undefined)
                                {
                                    return tile;

                                }


                               else if(Math.random() * 1.0 < chanceFloat)
                                {

                                    return tile;


                                }
                                else
                                {
                                    return false;

                                }

                            },

                            ground_tile_medium: function (chanceFloat) {

                                //return the next tile on a growing stack of tiles

                                if(Math.random() * 1.0 < chanceFloat)
                                {

                                    return new Sprite();


                                }
                                else
                                {
                                    return false;

                                }


                            },

                            spring: function (x, y, z, size, continuated) {

                                //return the next object

                            },

                            platform: function (x, y, z, size, continuated) {

                                //return the next object

                            },

                            moving_platform: function (x, y, z, size, continuated) {

                                //return the next object

                            },

                            super_platform: function (x, y, z, size, continuated) {

                                //return the next object

                            },

                            boost_point: function (x, y, z, size, continuated) {

                                //return the next object

                            },

                            moving_boost_point: function (x, y, z, size, continuated) {

                                //return the next object

                            }


                        };


                        var size_big = 500;


                        var size_medium = 250;

                        var size_small = 150;

                        var size_tiny = 75;


                        for (var x = 0; x < xLen; x++) {

                            var tile =  assembler.ground_tile_large(); //get reference to default ground tile


                            for (var y = 0; y < yLen; y++) {

                                var x1 = x * blockSize.x, x2 = x1 + blockSize.x,
                                    y1 = y * blockSize.y, y2 = y1 + blockSize.y;

                                if(x % assembler.ground_tile_large().size.x == 1)
                                {
                                    //tile placement point

                                    tile = tile ?  assembler.ground_tile_large(0.2) : false;


                                }

                                if(x % assembler.ground_tile_medium().size.x == 1)
                                {
                                    //tile placement point

                                    tile = tile ?  assembler.ground_tile_medium(0.2) : false;


                                }


                                if(tile)
                                {
                                    tile =


                                }


                            }

                        }

                    };


                    assembleLevel(10, 10, );

                }

            };


        function animate(time) {

            GameApp.update();

            TWEEN.update(time);

            GameApp.ctx.clearRect(0, 0, GameApp.canvas.width, GameApp.canvas.height);

            GameApp.render();

            requestAnimationFrame(animate);


        };

        Quazar.ready(function (lib) {


            GameApp.init();

            animate();


        });


    </script>


</body>
</html>